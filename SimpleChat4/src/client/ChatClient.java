// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com package client;import ocsf.client.*;import ocsf.server.OriginatorMessage;import common.*;import java.io.*;import java.util.LinkedList;import java.util.List;import java.util.Observable;import java.util.Observer;/** * This class overrides some of the methods defined in the abstract superclass * in order to give more functionality to the client. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave; * @author Fran&ccedil;ois B&eacute;langer * @version July 2000 */public class ChatClient implements Observer{	// Instance variables **********************************************	/**	 * The interface type variable. It allows the implementation of the display	 * method in the client.	 */	ChatIF clientUI;	private ObservableClient observableClient;	private static String QUIT_COMMAND = "#quit";	private static String LOGOFF_COMMAND = "#logoff";	private static String SET_HOST_COMMAND = "#sethost";	private static String SET_PORT_COMMAND = "#setport";	private static String LOGIN_COMMAND = "#login";	private static String GETHOST_COMMAND = "#gethost";	private static String GETPORT_COMMAND = "#getport";	private String[] commandes = { QUIT_COMMAND, LOGOFF_COMMAND,			SET_HOST_COMMAND, SET_PORT_COMMAND, LOGIN_COMMAND,			GETHOST_COMMAND, GETPORT_COMMAND };	/**	 * Identifiant du client	 */	private String id;	// Constructors ****************************************************	/**	 * Constructs an instance of the chat client.	 *	 * @param host	 *            The server to connect to.	 * @param port	 *            The port number to connect on.	 * @param clientUI	 *            The interface type variable.	 */	public ChatClient(String host, int port, ChatIF clientUI)			throws IOException {		//super(host, port); // Call the superclass constructor		this.clientUI = clientUI;		observableClient = new ObservableClient(host, port);		observableClient.addObserver(this);	}	public ChatClient(String id, String host, int port, ChatIF clientUI)			throws IOException {		//super(host, port); // Call the superclass constructor		this.id = id;		this.clientUI = clientUI;		observableClient = new ObservableClient(host, port);		observableClient.addObserver(this);	}	// Instance methods ************************************************	/**	 * This method handles all data that comes in from the server.	 *	 * @param msg	 *            The message from the server.	 */	private void handleMessageFromServer(Object msg) {		if(msg.equals("#close")){			clientUI.display("Server disconnected nicely");			try {				observableClient.closeConnection();			} catch (IOException e) {				e.printStackTrace();			}		}else{			clientUI.display(msg.toString());		}	}	/**	 * This method handles all data coming from the UI	 *	 * @param message	 *            The message from the UI.	 */	public void handleMessageFromClientUI(String message) {		try {			if(isCommand(message) != null){				if(message.equals(QUIT_COMMAND)){					observableClient.sendToServer(message);					observableClient.closeConnection();					System.exit(0);								}				else if(message.equals(LOGOFF_COMMAND)){					observableClient.sendToServer(QUIT_COMMAND);					observableClient.closeConnection();				}				else if(message.equals(GETHOST_COMMAND)){					clientUI.display("Host = "+observableClient.getHost());				}				else if(message.equals(GETPORT_COMMAND)){					clientUI.display("Port = "+observableClient.getPort());				}				else if(message.split(" ")[0].equals(LOGIN_COMMAND)){					String id = message.split(" ")[1];					if(!observableClient.isConnected()){						this.setId(id);						observableClient.openConnection();						observableClient.sendToServer(message);					}					else						System.out.println("Already connected");				}				else if(message.split(" ")[0].equals(SET_PORT_COMMAND)){					String port = message.split(" ")[1];					if(port.matches("[1-9]^4")){						observableClient.setPort(Integer.parseInt(port));					}					else						clientUI.display("Invalid command");								}				else if(message.split(" ")[0].equals(SET_HOST_COMMAND)){					if(!observableClient.isConnected()){						String host = message.split(" ")[1];						observableClient.setHost(host);					}					else						clientUI.display("Invalid host");				}			}			else if(message.equals("42")){				observableClient.sendToServer("   /\\_/\\  ");				observableClient.sendToServer("  / o o \\  ");				observableClient.sendToServer(" (   \"   ) ");				observableClient.sendToServer("  \\~(*)~/  ");				observableClient.sendToServer("   // \\\\  ");			}			else if (observableClient.isConnected())				observableClient.sendToServer(message);			else{				clientUI.display("please login (hint: use the command #login your_name)");			}		} catch (IOException e) {			clientUI.display("Could not send message to server.  Terminating client.");		}	}	/**	 * This method terminates the client.	 */	public void quit() {		try {			observableClient.closeConnection();		} catch (IOException e) {		}		System.exit(0);	}	private String isCommand(String message) {		if (message.charAt(0) == '#') {			String command = message.split(" ")[0];			for (String element : commandes) {				if (command.equals(element))					return command;			}		}		return null;	}	protected void connectionClosed() {		clientUI.display("Connection ended");	}	protected void connectionEstablished(){		clientUI.display("Connection established !");	}	protected void connectionException(Exception exception) {		clientUI.display("Exception thrown by the server");		connectionClosed();	}	public String getId(){		return id;	}	public void setId(String id){		this.id = id;	}	@Override	public void update(Observable o, Object arg) {		// TODO Auto-generated method stub		if(arg instanceof Exception){			connectionException((Exception)arg);		}		else{			switch((String) arg){			case ObservableClient.CONNECTION_ESTABLISHED:				connectionEstablished();				break;			case ObservableClient.CONNECTION_CLOSED:				connectionClosed();				break;			default:				handleMessageFromServer(arg);				break;			}		}	}}// End of ChatClient class